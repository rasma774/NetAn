import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np

__author__ = 'Rasmus Magnusson'
__COPYRIGHT__ = 'Copyright (C) 2023 Rasmus Magnusson'
__contact__ = 'rasma774@gmail.com'

_goldenratio = (1 + (5**(.5)))/2

def _corr_ax(ax, float_y=True):
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_linewidth(2)
    ax.spines['bottom'].set_linewidth(2)
    if float_y:
        ax.spines['bottom'].set_position(('outward', 20))
    ax.tick_params(axis='both',
                   width=2,
                   length=4,
                   labelsize=14)

def _get_template(n_subs):
    f, ax = plt.subplots(
        1,
        n_subs,
        figsize=(4*n_subs , 4*_goldenratio), sharey=True)

    # Small trick to not have to conv ax regardless of being itreable or not
    try:
        [_corr_ax(tmp, False) for tmp in ax]
        for ax_tmp in ax[1:]:
            ax_tmp.spines['left'].set_visible(False)
            ax_tmp.tick_params(axis='y',
                               which='both',
                               left=False,
                               labelleft=False)
    except TypeError:
        _corr_ax(ax)
    return f, ax

def _split_lines(lines, textlength):
    for i, lbl in enumerate(lines):
        if len(lbl) > textlength:
            # get where whitespace
            lbl = list(lbl)
            ws = np.where(np.array(lbl) == ' ')[0]
            if len(ws) < 2:
                continue
            if not ws[-2] <= textlength:
                # First place that breaks textlength
                place = ws[np.where(ws > textlength)][0]
                lbl = list(lbl)
                lbl[place] = '\n'
                lbl = ''.join(lbl)
                lines[i] = lbl
    return lines

def plot_enrichments(enr,
                     savename=None,
                     plot_Ntop=5,
                     textlength=30,
                     cmap=mpl.cm.OrRd,
                     sorton='OR',
                     padding=0.7,
                     ):
    """


    Parameters
    ----------
    enr : pandas.DataFrame
        The enrichment dataframe, as generated by NetAn.
    savename : str, optional
        Set a savename for direct saving. The default is None.
    plot_Ntop : int, optional
        The number of top annotations to plot. The default is 5.
    textlength : int, optional
        The number of characters before break line for tick labels.
        The default is 30.
    cmap : LinearSegmentedColormap from matplotlib.cm, optional
        Set what colormap to use. The default is matplotlib.cm.OrRd.
    sorton : str 'OR' | 'pval', optional
        Set on whether to sort enrichment results on p-values or Odds Ratios
        (OR). The default is 'OR'.
    padding : float, optional
        Change the distances between the bars. The default is 0.7.

    Returns
    -------
    f : matplotlib.pyplot.Figure
        Figure of results.
    ax : matplotlib.pyplot.Axes
        The axes of figure.

    """


    f, ax = _get_template(1)

    if plot_Ntop is None:
        plot_Ntop = (enr.p_adj <= 0.05).sum()

    if sorton == 'OR':
        enr = enr.sort_values('OR').iloc[::-1, :]
    elif sorton == 'pval':
        enr = enr.sort_values('p_adj')

    if np.any(enr.p_adj == 0):
        print('Replacing 0 p-values with smallest observed')
        p_adj_tmp = enr.p_adj.copy()
        smallest_nonzero = p_adj_tmp.unique()[1]
        p_adj_tmp [p_adj_tmp == 0] = smallest_nonzero
        enr['p_adj'] = p_adj_tmp
    p_trans = -np.log10(enr.p_adj)[:plot_Ntop]

    # For the colorbar
    norm = mpl.colors.Normalize(vmin=np.min((p_trans.min(),
                                             -np.log10(0.05))),
                                vmax=p_trans.max())

    if textlength is not None:
        labels = _split_lines(list(enr.index), textlength)

    for i in range(plot_Ntop):
        ax.barh(padding*(plot_Ntop - i),
                width=enr.OR[i],
                height=0.4, color=cmap(norm(p_trans[i])))

    ax.set_xlim([0, enr.OR[:i].max()*1.2])
    ax.set_yticks(padding*np.array(range(1, 1 + plot_Ntop)))
    ax.set_yticklabels(labels[:plot_Ntop][::-1])
    ax.set_xlabel('Odds Ratio', fontsize=17)
    colorbar = f.colorbar(mpl.cm.ScalarMappable(norm=norm,
                                                cmap=cmap),
                          ax=ax,
                          shrink=0.4,
                          pad = 0.15,
                          )
    colorbar.set_label(r'-log$_{10}$ p', fontsize=15, labelpad=-40)

    if  savename is not None:
        f.savefig(savename, bbox_inches='tight')

    return f, ax

def plot_enrichment_clusters(enrichments,
                     savename=None,
                     plot_Ntop=5,
                     textlength=30,
                     cmap=mpl.cm.OrRd,
                     sorton='OR',
                     padding=0.7,
                     ):

    """


    Parameters
    ----------
    enrichments : dict
        The dictionary of enrichments, as generated by NetAn.
    savename : str, optional
        Set a savename for direct saving. The default is None.
    plot_Ntop : int, optional
        The number of top annotations to plot. The default is 5.
    textlength : int, optional
        The number of characters before break line for tick labels.
        The default is 30.
    cmap : LinearSegmentedColormap from matplotlib.cm, optional
        Set what colormap to use. The default is matplotlib.cm.OrRd.
    sorton : str 'OR' | 'pval', optional
        Set on whether to sort enrichment results on p-values or Odds Ratios
        (OR). The default is 'OR'.
    padding : float, optional
        Change the distances between the bars. The default is 0.7.

    Returns
    -------
    f : matplotlib.pyplot.Figure
        Figure of results.
    ax : matplotlib.pyplot.Axes
        The axes of figure.

    """
    f, ax = _get_template(len(enrichments))

    all_ps = []
    all_annots = []
    for enr_key in enrichments:
        enr_tmp = enrichments[enr_key][0]
        if sorton == 'OR':
            enr_tmp.sort_values('OR')
        elif sorton == 'pval':
            enr_tmp.sort_values('p_adj')
        all_ps.append(-np.log10(enr_tmp.p_adj.values)[:plot_Ntop])
        labels = list(enr_tmp.index[:plot_Ntop].values[::-1])
        if textlength is not None:
            labels = _split_lines(labels, textlength)
        all_annots.append([labels,
                           all_ps[-1][::-1]])
    all_ps = np.concatenate(all_ps)

    if np.any(np.isinf(all_ps)):
        print('Replacing 0 p-values with smallest observed')
        all_ps[np.isinf(all_ps)] = np.unique(all_ps)[-2]

    norm = mpl.colors.Normalize(vmin=np.min((all_ps.min(),
                                             -np.log10(0.05))),
                                vmax=all_ps.max())

    for i in range(len(ax)):
        for j in range(plot_Ntop):
            ax[i].bar(padding*(plot_Ntop - j),
                    height=all_annots[i][1][j],
                    width=0.4, color=cmap(norm(all_annots[i][1][j])))
        ax[i].set_xticks(padding*np.array(range(1, 1 + plot_Ntop)))
        ax[i].set_xticklabels(all_annots[i][0], rotation=90)
    ax[0].set_ylabel('Odds Ratio', fontsize=17)
    colorbar = f.colorbar(mpl.cm.ScalarMappable(norm=norm,
                                                cmap=cmap),
                          ax=ax,
                          shrink=0.4,
                          pad = 0.15,
                          )
    colorbar.set_label(r'-log$_{10}$ p', fontsize=15, labelpad=-40)
    return f, ax
